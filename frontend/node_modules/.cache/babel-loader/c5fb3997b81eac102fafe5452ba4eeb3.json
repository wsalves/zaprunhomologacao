{"ast":null,"code":"\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.jsx\nvar src_exports = {};\n__export(src_exports, {\n  default: () => src_default\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_react = require(\"react\");\nvar import_prop_types = __toESM(require(\"prop-types\"));\nvar DefaultCanvasSize = 16;\nvar linkElements = [];\nvar drawAlert = (context, _ref) => {\n  let {\n    fillColor,\n    text,\n    textColor,\n    canvasSize\n  } = _ref;\n  const Padding = canvasSize / 5;\n  context.font = \"bold \".concat(canvasSize - Padding * 2, \"px arial\");\n  const w = Math.min(\n  // Take the text with if it's smaller than available space (eg: '2')\n  context.measureText(text).width,\n  // Or take the maximum size we'll force our text to fit in anyway (eg: '1000000')\n  canvasSize - Padding) + Padding;\n  const x = canvasSize - w;\n  const y = canvasSize / 2 - Padding;\n  const h = Padding + canvasSize / 2;\n  const r = Math.min(w / 2, h / 2);\n  context.beginPath();\n  context.moveTo(x + r, y);\n  context.arcTo(x + w, y, x + w, y + h, r);\n  context.arcTo(x + w, y + h, x, y + h, r);\n  context.arcTo(x, y + h, x, y, r);\n  context.arcTo(x, y, x + w, y, r);\n  context.closePath();\n  context.fillStyle = fillColor;\n  context.fill();\n  context.fillStyle = textColor;\n  context.textBaseline = \"bottom\";\n  context.textAlign = \"right\";\n  context.fillText(text, canvasSize - Padding / 2, canvasSize,\n  // This will prevent the text from going outside the favicon, instead it'll squeeze his with to fit in\n  canvasSize - Padding);\n};\nvar drawIcon = _ref2 => {\n  let {\n    alertCount,\n    alertFillColor,\n    alertTextColor,\n    callback,\n    renderOverlay,\n    url: src,\n    canvasSize\n  } = _ref2;\n  const img = document.createElement(\"img\");\n  img.crossOrigin = \"Anonymous\";\n  img.onload = function () {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = canvasSize;\n    canvas.height = canvasSize;\n    const context = canvas.getContext(\"2d\");\n    context.clearRect(0, 0, img.width, img.height);\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    if (alertCount) {\n      drawAlert(context, {\n        fillColor: alertFillColor,\n        textColor: alertTextColor,\n        text: alertCount,\n        canvasSize\n      });\n    }\n    if (renderOverlay) {\n      renderOverlay(canvas, context);\n    }\n    callback(context.canvas.toDataURL());\n  };\n  img.src = src;\n};\nvar updateHtmlIconLink = keepIconLink => {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n  if (linkElements.length === 0) {\n    var head = document.getElementsByTagName(\"head\")[0];\n    const linkEl = document.createElement(\"link\");\n    linkEl.type = \"image/x-icon\";\n    linkEl.rel = \"icon\";\n    const linkApple = document.createElement(\"link\");\n    linkApple.rel = \"apple-touch-icon\";\n    linkElements.push(linkEl, linkApple);\n    var links = head.getElementsByTagName(\"link\");\n    for (var i = links.length; --i >= 0;) {\n      if (/\\bicon\\b/i.test(links[i].getAttribute(\"rel\")) && !keepIconLink(links[i])) {\n        head.removeChild(links[i]);\n      }\n    }\n    linkElements.forEach(el => head.appendChild(el));\n  }\n};\nvar Favicon = _ref3 => {\n  let {\n    iconSize,\n    alertCount,\n    alertFillColor,\n    alertTextColor,\n    animated,\n    animationDelay,\n    keepIconLink,\n    renderOverlay,\n    url\n  } = _ref3;\n  const animationIndex = (0, import_react.useRef)(0);\n  const animationTickIntervalId = (0, import_react.useRef)(null);\n  const [, updateState] = (0, import_react.useState)();\n  const forceUpdate = (0, import_react.useCallback)(() => updateState({}), []);\n  const onAnimationTick = (0, import_react.useCallback)(() => {\n    updateHtmlIconLink(keepIconLink);\n    animationIndex.current = (animationIndex.current + 1) % url.length;\n    forceUpdate();\n  }, [forceUpdate, keepIconLink, url]);\n  (0, import_react.useEffect)(() => {\n    onAnimationTick();\n  }, [onAnimationTick]);\n  const isAnimated = url instanceof Array && animated;\n  (0, import_react.useEffect)(() => {\n    if (isAnimated) {\n      if (!animationTickIntervalId.current) {\n        const intervalId = setInterval(onAnimationTick, animationDelay);\n        animationTickIntervalId.current = intervalId;\n      }\n    } else {\n      if (animationTickIntervalId.current) {\n        clearInterval(animationTickIntervalId.current);\n        animationTickIntervalId.current = null;\n        updateHtmlIconLink(keepIconLink);\n      }\n    }\n  }, [animationDelay, isAnimated, keepIconLink, onAnimationTick, url]);\n  const currentUrl = isAnimated ? url[animationIndex.current] : url instanceof Array ? url[0] : url;\n  if (alertCount || renderOverlay) {\n    drawIcon({\n      alertCount,\n      alertFillColor,\n      alertTextColor,\n      callback: url2 => {\n        linkElements.forEach(el => el.href = url2);\n      },\n      renderOverlay,\n      url: currentUrl,\n      canvasSize: iconSize\n    });\n  } else {\n    linkElements.forEach(el => el.href = currentUrl);\n  }\n  return null;\n};\nFavicon.defaultProps = {\n  iconSize: DefaultCanvasSize,\n  alertCount: null,\n  alertFillColor: \"red\",\n  alertTextColor: \"white\",\n  animated: true,\n  animationDelay: 500,\n  keepIconLink: () => false,\n  renderOverlay: null,\n  url: null\n};\nFavicon.propTypes = {\n  iconSize: import_prop_types.default.number,\n  alertCount: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),\n  alertFillColor: import_prop_types.default.string,\n  alertTextColor: import_prop_types.default.string,\n  animated: import_prop_types.default.bool,\n  animationDelay: import_prop_types.default.number,\n  keepIconLink: import_prop_types.default.func,\n  renderOverlay: import_prop_types.default.func,\n  url: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string), import_prop_types.default.string]).isRequired\n};\nvar src_default = Favicon;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {});\nmodule.exports = module.exports.default;","map":null,"metadata":{},"sourceType":"script"}