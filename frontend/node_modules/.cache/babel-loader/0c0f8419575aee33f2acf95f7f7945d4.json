{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport frequently from '../utils/frequently';\nimport { getData } from '../utils';\nimport NimbleEmoji from './emoji/nimble-emoji';\nimport NotFound from './not-found';\nvar Category = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Category, _React$Component);\n  function Category(props) {\n    var _this;\n    _classCallCheck(this, Category);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Category).call(this, props));\n    _this.data = props.data;\n    _this.setContainerRef = _this.setContainerRef.bind(_assertThisInitialized(_this));\n    _this.setLabelRef = _this.setLabelRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  _createClass(Category, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.margin = 0;\n      this.minMargin = 0;\n      this.memoizeSize();\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var _this$props = this.props,\n        name = _this$props.name,\n        perLine = _this$props.perLine,\n        _native = _this$props[\"native\"],\n        hasStickyPosition = _this$props.hasStickyPosition,\n        emojis = _this$props.emojis,\n        emojiProps = _this$props.emojiProps,\n        skin = emojiProps.skin,\n        size = emojiProps.size,\n        set = emojiProps.set,\n        nextPerLine = nextProps.perLine,\n        nextNative = nextProps[\"native\"],\n        nextHasStickyPosition = nextProps.hasStickyPosition,\n        nextEmojis = nextProps.emojis,\n        nextEmojiProps = nextProps.emojiProps,\n        nextSkin = nextEmojiProps.skin,\n        nextSize = nextEmojiProps.size,\n        nextSet = nextEmojiProps.set,\n        shouldUpdate = false;\n      if (name == 'Recent' && perLine != nextPerLine) {\n        shouldUpdate = true;\n      }\n      if (name == 'Search') {\n        shouldUpdate = !(emojis == nextEmojis);\n      }\n      if (skin != nextSkin || size != nextSize || _native != nextNative || set != nextSet || hasStickyPosition != nextHasStickyPosition) {\n        shouldUpdate = true;\n      }\n      return shouldUpdate;\n    }\n  }, {\n    key: \"memoizeSize\",\n    value: function memoizeSize() {\n      if (!this.container) {\n        // probably this is a test environment, e.g. jest\n        this.top = 0;\n        this.maxMargin = 0;\n        return;\n      }\n      var parent = this.container.parentElement;\n      var _this$container$getBo = this.container.getBoundingClientRect(),\n        top = _this$container$getBo.top,\n        height = _this$container$getBo.height;\n      var _parent$getBoundingCl = parent.getBoundingClientRect(),\n        parentTop = _parent$getBoundingCl.top;\n      var _this$label$getBoundi = this.label.getBoundingClientRect(),\n        labelHeight = _this$label$getBoundi.height;\n      this.top = top - parentTop + parent.scrollTop;\n      if (height == 0) {\n        this.maxMargin = 0;\n      } else {\n        this.maxMargin = height - labelHeight;\n      }\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll(scrollTop) {\n      var margin = scrollTop - this.top;\n      margin = margin < this.minMargin ? this.minMargin : margin;\n      margin = margin > this.maxMargin ? this.maxMargin : margin;\n      if (margin == this.margin) return;\n      if (!this.props.hasStickyPosition) {\n        this.label.style.top = \"\".concat(margin, \"px\");\n      }\n      this.margin = margin;\n      return true;\n    }\n  }, {\n    key: \"getEmojis\",\n    value: function getEmojis() {\n      var _this2 = this;\n      var _this$props2 = this.props,\n        name = _this$props2.name,\n        emojis = _this$props2.emojis,\n        recent = _this$props2.recent,\n        perLine = _this$props2.perLine;\n      if (name == 'Recent') {\n        var custom = this.props.custom;\n        var frequentlyUsed = recent || frequently.get(perLine);\n        if (frequentlyUsed.length) {\n          emojis = frequentlyUsed.map(function (id) {\n            var emoji = custom.filter(function (e) {\n              return e.id === id;\n            })[0];\n            if (emoji) {\n              return emoji;\n            }\n            return id;\n          }).filter(function (id) {\n            return !!getData(id, null, null, _this2.data);\n          });\n        }\n        if (emojis.length === 0 && frequentlyUsed.length > 0) {\n          return null;\n        }\n      }\n      if (emojis) {\n        emojis = emojis.slice(0);\n      }\n      return emojis;\n    }\n  }, {\n    key: \"updateDisplay\",\n    value: function updateDisplay(display) {\n      var emojis = this.getEmojis();\n      if (!emojis || !this.container) {\n        return;\n      }\n      this.container.style.display = display;\n    }\n  }, {\n    key: \"setContainerRef\",\n    value: function setContainerRef(c) {\n      this.container = c;\n    }\n  }, {\n    key: \"setLabelRef\",\n    value: function setLabelRef(c) {\n      this.label = c;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var _this$props3 = this.props,\n        id = _this$props3.id,\n        name = _this$props3.name,\n        hasStickyPosition = _this$props3.hasStickyPosition,\n        emojiProps = _this$props3.emojiProps,\n        i18n = _this$props3.i18n,\n        notFound = _this$props3.notFound,\n        notFoundEmoji = _this$props3.notFoundEmoji,\n        emojis = this.getEmojis(),\n        labelStyles = {},\n        labelSpanStyles = {},\n        containerStyles = {};\n      if (!emojis) {\n        containerStyles = {\n          display: 'none'\n        };\n      }\n      if (!hasStickyPosition) {\n        labelStyles = {\n          height: 28\n        };\n        labelSpanStyles = {\n          position: 'absolute'\n        };\n      }\n      var label = i18n.categories[id] || name;\n      return React.createElement(\"section\", {\n        ref: this.setContainerRef,\n        className: \"emoji-mart-category\",\n        \"aria-label\": label,\n        style: containerStyles\n      }, React.createElement(\"div\", {\n        style: labelStyles,\n        \"data-name\": name,\n        className: \"emoji-mart-category-label\"\n      }, React.createElement(\"span\", {\n        style: labelSpanStyles,\n        ref: this.setLabelRef,\n        \"aria-hidden\": true\n        /* already labeled by the section aria-label */\n      }, label)), React.createElement(\"ul\", {\n        className: \"emoji-mart-category-list\"\n      }, emojis && emojis.map(function (emoji) {\n        return React.createElement(\"li\", {\n          key: emoji.short_names && emoji.short_names.join('_') || emoji\n        }, NimbleEmoji(_objectSpread({\n          emoji: emoji,\n          data: _this3.data\n        }, emojiProps)));\n      })), emojis && !emojis.length && React.createElement(NotFound, {\n        i18n: i18n,\n        notFound: notFound,\n        notFoundEmoji: notFoundEmoji,\n        data: this.data,\n        emojiProps: emojiProps\n      }));\n    }\n  }]);\n  return Category;\n}(React.Component);\nexport { Category as default };\nCategory.propTypes\n/* remove-proptypes */ = {\n  emojis: PropTypes.array,\n  hasStickyPosition: PropTypes.bool,\n  name: PropTypes.string.isRequired,\n  \"native\": PropTypes.bool.isRequired,\n  perLine: PropTypes.number.isRequired,\n  emojiProps: PropTypes.object.isRequired,\n  recent: PropTypes.arrayOf(PropTypes.string),\n  notFound: PropTypes.func,\n  notFoundEmoji: PropTypes.string.isRequired\n};\nCategory.defaultProps = {\n  emojis: [],\n  hasStickyPosition: true\n};","map":null,"metadata":{},"sourceType":"module"}